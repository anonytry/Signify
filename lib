# SPDX-License-Identifier: Apache-2.0
# Signify base

[[ "${BASH_SOURCE[0]}" != "$0" ]] || {
    echo "This file is part of Signify. Do not run directly."
    exit 1
}

# ==============================
# HELPER FUNCTIONS
# ==============================
green()  { echo -e "\e[1;32m$1\e[0m"; }
yellow() { echo -e "\e[1;33m$1\e[0m"; }

confirm() {
    while true; do
        read -r -p "$1 (yes/no): " input
        case "$input" in
            [yY][eE][sS]|[yY]) echo "yes"; return ;;
            [nN][oO]|[nN]) echo "no"; return ;;
        esac
    done
}

prompt() {
    while true; do
        read -p "$1" input
        [[ -n "$input" ]] && echo "$input" && return
    done
}

prompt_key_size() {
    while true; do
        read -p "$1" input
        [[ "$input" == "2048" || "$input" == "4096" ]] && echo "$input" && return
    done
}

# ==============================
# PATHS
# ==============================
if [[ -z "$ROM_ROOT" ]]; then
    echo "Error: ROM_ROOT not set. Run Signify from ROM root."
    exit 1
fi

MAKE_KEY="$ROM_ROOT/development/tools/make_key"

# ==============================
# MAIN FUNCTIONS
# ==============================
generate_certificates() {
    mkdir -p "$KEYS_DIR"

    if [ ! -x "$MAKE_KEY" ]; then
        echo "Error: make_key not found at $MAKE_KEY"
        exit 1
    fi

    green "\n→ Generating certificates inside $KEYS_DIR..."

    set +e

    # Generate standard certs (platform, media, shared, etc.)
    for certificate in "${certificates[@]}"; do
        if [[ -f "$KEYS_DIR/$certificate.pk8" ]]; then
            echo "• $certificate already exists → skipped"
            continue
        fi
        echo "• Generating $certificate ..."
        bash "$MAKE_KEY" "$KEYS_DIR/$certificate" "$SUBJECT"
    done

    # Generate APEX certs (base key only, NOT override name)
    for apex in "${apex_certificates[@]}"; do
        safe="${apex//./_}"

        if [[ -f "$KEYS_DIR/$safe.pk8" ]]; then
            echo "• $safe already exists → skipped"
            continue
        fi

        echo "• Generating $safe ..."
        bash "$MAKE_KEY" "$KEYS_DIR/$safe" "$SUBJECT"
    done

    set -e

    create_releasekey
    write_android_bp
    write_product_keys_mk
}

create_releasekey() {
    if [[ -f "$KEYS_DIR/releasekey.pk8" ]]; then
        yellow "→ releasekey already exists — skipping"
        return
    fi

    green "\n→ Generating releasekey..."
    bash "$MAKE_KEY" "$KEYS_DIR/releasekey" "$SUBJECT" || true
}

# ==============================
# ANDROID.BP GENERATION
# ==============================
write_android_bp() {
    green "→ Writing Android.bp..."

    {
        for apex in "${apex_certificates[@]}"; do
            safe="${apex//./_}"

            echo "android_app_certificate {"
            echo "    name: \"$safe.certificate.override\","
            echo "    certificate: \"$safe\","
            echo "}"
            echo ""
        done
    } > "$KEYS_DIR/Android.bp"
}

# ==============================
# KEYS.MK GENERATION
# ==============================
write_product_keys_mk() {
    green "→ Writing keys.mk..."

    {
        echo "PRODUCT_CERTIFICATE_OVERRIDES := \\"

        for apex in "${apex_certificates[@]}"; do
            safe="${apex//./_}"
            echo "    $apex:$safe.certificate.override \\"
        done

        echo ""
        echo "PRODUCT_DEFAULT_DEV_CERTIFICATE := $KEYS_DIR/releasekey"
        echo "PRODUCT_MAINLINE_BLUETOOTH_SEPOLICY_DEV_CERTIFICATES := \$(dir \$(PRODUCT_DEFAULT_DEV_CERTIFICATE))"
        echo "PRODUCT_OTA_PUBLIC_KEYS := $KEYS_DIR/otakey.x509.pem"
        echo "PRODUCT_EXTRA_RECOVERY_KEYS :="
    } > "$KEYS_DIR/keys.mk"
}
